# VTFS - Versioned Tree Filesystem

[![License: GPL v2](https://img.shields.io/badge/License-GPL_v2-blue.svg)](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)

VTFS (Versioned Tree Filesystem) — это учебно-экспериментальная файловая система для Linux, реализованная как модуль ядра. Она хранит все данные в оперативной памяти (RAM), а все изменения синхронно отправляет на внешний HTTP-сервер. При монтировании состояние файловой системы восстанавливается с этого же сервера.

Проект демонстрирует глубокую интеграцию с VFS (Virtual Filesystem Switch) ядра Linux, работу с inode, dentry, суперблоком, а также взаимодействие с пользовательским пространством через HTTP.

## Архитектура

VTFS состоит из двух основных компонентов:

1. **Модуль ядра (`vtfs.ko`):** Реализует логику файловой системы.
   - Хранит иерархию (`vtfs_node`) и данные файлов (`vtfs_file`) в ОЗУ.
   - Перехватывает системные вызовы VFS (через `file_operations`, `inode_operations`).
   - При любом изменении (создание, запись, удаление) отправляет **push-уведомление** на сервер по HTTP.
   - При монтировании выполняет **restore** — загружает полное состояние файловой системы с сервера.

2. **Сервер состояния (`server.py`):** Легковесный HTTP-сервер на Python.
   - Хранит состояние ФС в JSON-файле, может быть легко перенесено в СУБД.
   - Предоставляет REST API для всех операций (`mkdir`, `write`, `read` и т.д.).
   - Обрабатывает конкурентный доступ с помощью блокировок.
   - Выступает в роли единственного источника правды (source of truth).

## Возможности

- **Полная прозрачность:** Файловая система монтируется как обычная и поддерживает стандартные операции:
  - `ls`, `mkdir`, `rmdir`, `touch`, `rm`, `ln`
  - Чтение и запись файлов (`cat`, `echo`, редакторы)
  - Работа с правами доступа (permissions)
- **Синхронность:** Все изменения немедленно отправляются на сервер. В случае падения модуля или перезагрузки, данные не теряются и восстанавливаются при следующем монтировании.
- **Поддержка жестких ссылок (hard links):** Реализована полноценная работа со счетчиком ссылок как на стороне ядра, так и на сервере.
- **Крос-версионность:** Благодаря тому, что состояние полностью хранится на сервере, несколько клиентов могут работать с разными "слепками" данных, просто указав разные токены.

## Как это работает

### Монтирование (Restore)

1. Модуль загружается в ядро. Параметром передается `token`.
2. При монтировании модуль отправляет HTTP GET `dump` на сервер.
3. Сервер возвращает плоский список всех узлов (файлов, директорий), отсортированный так, чтобы родители создавались раньше детей.
4. Модуль парсит ответ и реконструирует в памяти дерево директорий и содержимое файлов.

### Модификация (Push)

1. Пользователь выполняет команду (`touch file.txt`).
2. VFS вызывает соответствующую функцию модуля (например, `vtfs_create`).
3. Модуль создает новый узел `vtfs_node` в памяти.
4. Модуль формирует HTTP-запрос (`/api/create?parent=...&name=...&ino=...`) и отправляет его на сервер.
5. Сервер сохраняет изменения в JSON.
6. Если HTTP-запрос неудачен, операция в ядре также завершается ошибкой, и узел не создается (или удаляется).

## Сборка и установка

### Требования

- Заголовочные файлы ядра Linux
- Компилятор GCC
- Python 3 для запуска сервера

### Шаг 1: Сборка модуля ядра

В директории с исходными кодами выполните:

```bash
make
```

### Шаг 2: Запуск сервера

По умолчанию сервер слушает порт 8080 и сохраняет состояние в `./vtfs_state.json`.

```bash
python3 server.py
```

Для изменения параметров используйте переменные окружения:

```bash
export VTFS_PORT=9090
export VTFS_STATE=/path/to/state.json
python3 server.py
```

### Шаг 3: Загрузка модуля и монтирование

```bash
# Загружаем модуль
sudo insmod vtfs.ko

# Создаем точку монтирования
sudo mkdir /mnt/vtfs

# Монтируем файловую систему с указанием токена
sudo mount -t vtfs -o token=my_test_token none /mnt/vtfs
```

Теперь можно работать с ФС в `/mnt/vtfs`.

### Шаг 4: Размонтирование и выгрузка

```bash
sudo umount /mnt/vtfs
sudo rmmod vtfs
```

### Обобщение

Для загрузки модуля и монтирования

```bash
# Собираем модуль
make

# Загружаем модуль
make load

# Создаем точку монтирования
make mount
```

Для размонтирования, выгрузки и очистки

```bash
make umount
make unload
make clean
```


## API сервера

Сервер предоставляет JSON-RPC подобный API через HTTP GET. Все параметры передаются в query string.

- **Успех:** Возвращает `[int64:0][payload]`
- **Ошибка:** Возвращает `[int64:код_ошибки]`

**Основные эндпоинты:**

- `GET /api/dump` — получить полный дамп состояния ФС для восстановления.
- `GET /api/mkdir?parent=<pino>&name=<name>&ino=<ino>` — создать директорию.
- `GET /api/create?parent=<pino>&name=<name>&ino=<ino>` — создать файл.
- `GET /api/write?ino=<ino>&off=<off>&data=<b64_data>` — записать данные.
- `GET /api/read?ino=<ino>&off=<off>&len=<len>` — прочитать данные.
- `GET /api/link?old=<target_ino>&parent=<pino>&name=<name>` — создать жесткую ссылку.
- `GET /api/unlink?parent=<pino>&name=<name>` — удалить файл (запись).
- `GET /api/rmdir?parent=<pino>&name=<name>` — удалить директорию.

*(Полный список эндпоинтов смотрите в исходном коде `server.py`)*

## Структура проекта

- `vtfs.h` — Основной заголовочный файл с определениями структур и функций.
- `vtfs_main.c` — Инициализация и регистрация файловой системы в ядре.
- `super.c` — Операции с суперблоком (монтирование, размонтирование).
- `inode.c` — Создание и настройка inode.
- `ops.c` — Inode-операции (`mkdir`, `create`, `unlink`, `link`).
- `dir.c` — Directory-операции (чтение директории `iterate`).
- `file.c` — File-операции (`open`, `read`, `write`).
- `store.c` — Управление RAM-хранилищем (деревья узлов, аллокация).
- `remote.c` — HTTP-клиент для push-операций.
- `restore.c` — HTTP-клиент для восстановления (restore) при монтировании.
- `http.c` / `http.h` — Низкоуровневая работа с сокетами и HTTP.
- `server.py` — HTTP-сервер для хранения состояния.

## Лицензия

Проект распространяется под лицензией GPL v2, так как является производной работой от ядра Linux.